Only in SDL_gfx-2.0.23-xcs: config.log
Only in SDL_gfx-2.0.23-xcs: config.status
Only in SDL_gfx-2.0.23-xcs: .deps
Common subdirectories: SDL_gfx-2.0.23/Docs and SDL_gfx-2.0.23-xcs/Docs
Common subdirectories: SDL_gfx-2.0.23/Fonts and SDL_gfx-2.0.23-xcs/Fonts
Only in SDL_gfx-2.0.23-xcs: libtool
Common subdirectories: SDL_gfx-2.0.23/m4 and SDL_gfx-2.0.23-xcs/m4
Only in SDL_gfx-2.0.23-xcs: Makefile
Common subdirectories: SDL_gfx-2.0.23/Other Builds and SDL_gfx-2.0.23-xcs/Other Builds
Common subdirectories: SDL_gfx-2.0.23/Scripts and SDL_gfx-2.0.23-xcs/Scripts
Only in SDL_gfx-2.0.23-xcs: SDL_gfxFastDraw.c
Only in SDL_gfx-2.0.23-xcs: SDL_gfxFastDraw.x
Only in SDL_gfx-2.0.23-xcs: SDL_gfx.pc
diff SDL_gfx-2.0.23/SDL_gfxPrimitives.c SDL_gfx-2.0.23-xcs/SDL_gfxPrimitives.c
5,27c5,27
< Copyright (C) 2001-2011  Andreas Schiffler
< 
< This software is provided 'as-is', without any express or implied
< warranty. In no event will the authors be held liable for any damages
< arising from the use of this software.
< 
< Permission is granted to anyone to use this software for any purpose,
< including commercial applications, and to alter it and redistribute it
< freely, subject to the following restrictions:
< 
<    1. The origin of this software must not be misrepresented; you must not
<    claim that you wrote the original software. If you use this software
<    in a product, an acknowledgment in the product documentation would be
<    appreciated but is not required.
< 
<    2. Altered source versions must be plainly marked as such, and must not be
<    misrepresented as being the original software.
< 
<    3. This notice may not be removed or altered from any source
<    distribution.
< 
< Andreas Schiffler -- aschiffler at ferzkopp dot net
< 
---
> Copyright (C) 2001-2011  Andreas Schiffler
> 
> This software is provided 'as-is', without any express or implied
> warranty. In no event will the authors be held liable for any damages
> arising from the use of this software.
> 
> Permission is granted to anyone to use this software for any purpose,
> including commercial applications, and to alter it and redistribute it
> freely, subject to the following restrictions:
> 
>    1. The origin of this software must not be misrepresented; you must not
>    claim that you wrote the original software. If you use this software
>    in a product, an acknowledgment in the product documentation would be
>    appreciated but is not required.
> 
>    2. Altered source versions must be plainly marked as such, and must not be
>    misrepresented as being the original software.
> 
>    3. This notice may not be removed or altered from any source
>    distribution.
> 
> Andreas Schiffler -- aschiffler at ferzkopp dot net
> 
45a46,51
> typedef void (*drawPointer)( SDL_Surface *dst, Sint16 x, Sint16 y, Uint32 color, Uint8 alpha );
> 
> /* Establish the correct drawing routing based on if it uses alpha blending or not */
> drawPointer getDrawRoutine( SDL_Surface *dst, Uint8 alpha );
> 
> 
65a72,75
>         Uint32 mcolor;
>         Uint8 alpha;
>         Uint8 pattern;
>   drawPointer drawRoutine;
74a85,93
> 
> 
> 
> 
> 
> 
> 
> 
> 
268a288,291
> 
> 
> 
> 
485a509,548
> \brief Internal pixel drawing function with patterning and alpha blending where input color is in destination format.
> 
> Contains two alternative 32 bit alpha blending routines which can be enabled at the source
> level with the defines DEFAULT_ALPHA_PIXEL_ROUTINE or EXPERIMENTAL_ALPHA_PIXEL_ROUTINE.
> Only the bits up to the surface depth are significant in the color value.
> 
> \param dst The surface to draw on.
> \param x The horizontal coordinate of the pixel.
> \param y The vertical position of the pixel.
> \param color The color value of the pixel to draw. 
> \param alpha The blend factor to apply while drawing.
> \param pattern The pattern to apply
> 
> \returns Returns 0 on success, -1 on failure.
> */
> int _putPixelPatterenedAlpha(SDL_Surface *dst, Sint16 x, Sint16 y, Uint32 color, Uint8 alpha, Uint8 pattern)
> {
>   
>   switch( pattern ) {
>   case 1: /* longitudinal stripes */
>     if( x & 1 ) return 1;
>     break;
>   case 2: /* traverse stripes */
>     if( y & 1 ) return 1;
>     break;
>   case 3: /* checkerboard */
>     if( (x & 1)^(y & 1) ) return 1;
>     break;
>   case 4: /* diagonal1 */
>     if( (x+y) & 3 ) return 1;
>     break;
>   case 5: /* diagonal2 */
>     if( (x-y) & 3 ) return 1;
>     break;
>   }
>     
>   return _putPixelAlpha( dst, x, y, color, alpha );
> }
> 
> /*!
4991a5055,5165
> int thickPolygonColor(SDL_Surface * dst, const Sint16 * vx, const Sint16 * vy, int n, Uint8 width, Uint32 color)
> {
> 	int result;
> 	int i;
> 	const Sint16 *x1, *y1, *x2, *y2;
> 
> 	/*
> 	* Check visibility of clipping rectangle
> 	*/
> 	if ((dst->clip_rect.w==0) || (dst->clip_rect.h==0)) {
> 		return(0);
> 	}
> 
> 	/*
> 	* Vertex array NULL check 
> 	*/
> 	if (vx == NULL) {
> 		return (-1);
> 	}
> 	if (vy == NULL) {
> 		return (-1);
> 	}
> 
> 	/*
> 	* Sanity check 
> 	*/
> 	if (n < 3) {
> 		return (-1);
> 	}
> 
> 	/*
> 	* Pointer setup 
> 	*/
> 	x1 = x2 = vx;
> 	y1 = y2 = vy;
> 	x2++;
> 	y2++;
> 
> 	/*
> 	* Draw 
> 	*/
> 	result = 0;
> 	for (i = 1; i < n; i++) {
>          	result |= thickLineColor(dst, *x1, *y1, *x2, *y2, width, color);
> 		x1 = x2;
> 		y1 = y2;
> 		x2++;
> 		y2++;
> 	}
> 	result |= thickLineColor(dst, *x1, *y1, *vx, *vy, width, color);
> 
> 	return (result);
> }
> 
> #if 0
> int thickPatternedPolygonColor(SDL_Surface * dst, const Sint16 * vx, const Sint16 * vy, int n, Uint8 width, Uint32 color, Uint8 pattern)
> {
> 	int result;
> 	int i;
> 	const Sint16 *x1, *y1, *x2, *y2;
> 
> 	/*
> 	* Check visibility of clipping rectangle
> 	*/
> 	if ((dst->clip_rect.w==0) || (dst->clip_rect.h==0)) {
> 		return(0);
> 	}
> 
> 	/*
> 	* Vertex array NULL check 
> 	*/
> 	if (vx == NULL) {
> 		return (-1);
> 	}
> 	if (vy == NULL) {
> 		return (-1);
> 	}
> 
> 	/*
> 	* Sanity check 
> 	*/
> 	if (n < 3) {
> 		return (-1);
> 	}
> 
> 	/*
> 	* Pointer setup 
> 	*/
> 	x1 = x2 = vx;
> 	y1 = y2 = vy;
> 	x2++;
> 	y2++;
> 
> 	/*
> 	* Draw 
> 	*/
> 	result = 0;
> 	for (i = 1; i < n; i++) {
> 	        result |= thickPatternedLineColor(dst, *x1, *y1, *x2, *y2, width, color, pattern);
> 		x1 = x2;
> 		y1 = y2;
> 		x2++;
> 		y2++;
> 	}
> 	result |= thickPatternedLineColor(dst, *x1, *y1, *vx, *vy, width, color, pattern );
> 
> 	return (result);
> }
> 
> #endif 
> 
6383,6388d6556
< 	/*
< 	* Lock the surface 
< 	*/
< 	if (SDL_MUSTLOCK(m->dst)) {
< 		SDL_LockSurface(m->dst);
< 	}
6392c6560,6561
< 		pixelColorNolock(m->dst, x, y, m->color);
---
> 	  (*m->drawRoutine)(m->dst,x,y,m->mcolor,m->alpha);
> 	  //		_putPixelAlpha(m->dst, x, y, m->mcolor, m->alpha );
6416,6419d6584
< 	/* Unlock surface */
< 	if (SDL_MUSTLOCK(m->dst)) {
< 		SDL_UnlockSurface(m->dst);
< 	}
6453,6458c6618,6623
< 			fix = (m->first1x + m->first2x) / 2;
< 			fiy = (m->first1y + m->first2y) / 2;
< 			lax = (m->last1x + m->last2x) / 2;
< 			lay = (m->last1y + m->last2y) / 2;
< 			curx = (ml1x + ml2x) / 2;
< 			cury = (ml1y + ml2y) / 2;
---
> 			fix = (m->first1x + m->first2x) >> 1;
> 			fiy = (m->first1y + m->first2y) >> 1;
> 			lax = (m->last1x + m->last2x) >> 1;
> 			lay = (m->last1y + m->last2y) >> 1;
> 			curx = (ml1x + ml2x) >> 1;
> 			cury = (ml1y + ml2y) >> 1;
6501,6506d6665
< 			/*
< 			* Lock the surface 
< 			*/
< 			if (SDL_MUSTLOCK(m->dst)) {
< 				SDL_LockSurface(m->dst);
< 			}
6510c6669,6670
< 				pixelColorNolock(m->dst, b.x, b.y, m->color);
---
> 			  (*m->drawRoutine)(m->dst,b.x,b.y,m->mcolor,m->alpha);
> 			  //  _putPixelAlpha(m->dst, b.x, b.y, m->mcolor, m->alpha );
6515c6675,6676
< 				pixelColorNolock(m->dst, b.x, b.y, m->color);
---
> 			  (*m->drawRoutine)(m->dst,b.x,b.y,m->mcolor,m->alpha);
> 			  //			       _putPixelAlpha(m->dst, b.x, b.y, m->mcolor, m->alpha );
6520c6681,6682
< 				pixelColorNolock(m->dst, b.x, b.y, m->color);
---
> 			  (*m->drawRoutine)(m->dst,b.x,b.y,m->mcolor,m->alpha);
> 			  //		       _putPixelAlpha(m->dst, b.x, b.y, m->mcolor, m->alpha );
6525c6687,6688
< 				pixelColorNolock(m->dst, b.x, b.y, m->color);
---
> 			  (*m->drawRoutine)(m->dst,b.x,b.y,m->mcolor,m->alpha);
> 			  //			       _putPixelAlpha(m->dst, b.x, b.y, m->mcolor, m->alpha );
6528,6533c6691
< 			/* Unlock surface */
< 			if (SDL_MUSTLOCK(m->dst)) {
< 				SDL_UnlockSurface(m->dst);
< 			}
< 
< 			px[0] = m1x;
---
> 			/*			px[0] = m1x;
6541c6699
< 			polygonColor(m->dst, px, py, 4, m->color);						
---
> 			polygonColor(m->dst, px, py, 4, m->color); */
6592c6750,6753
< 	
---
> 
> 	/*
> 	* Draw 
> 	*/
6599c6760
< 		y1 = temp;		
---
> 		y2 = temp;		
6632a6794
> 
6636c6798
< 			pty = y1 - (Sint16)lrint(offset * cang);
---
> 		  pty = y1 - (Sint16)lrint(offset * cang);
6638c6800
< 			pty = y1 + (Sint16)lrint(offset * cang);
---
> 		  pty = y1 + (Sint16)lrint(offset * cang);
6762a6925,6929
> 	m.alpha = color & 0x000000ff;
> 	m.mcolor = SDL_MapRGBA(dst->format, (color & 0xff000000) >> 24,
> 			       (color & 0x00ff0000) >> 16, (color & 0x0000ff00) >> 8, m.alpha);
> 	m.pattern = 0;
> 
6766c6933
< 	/* Special case: thick "point" */
---
> 	/* Special case: thick "point"  */
6768,6769c6935
< 		wh = width / 2;
< 		return boxColor(dst, x1 - wh, y1 - wh, x2 + width, y2 + width, color);		
---
> 	  return;
6770a6937,6939
> 	/*	wh = width / 2;
> 		return boxColor(dst, x1 - wh, y1 - wh, x2 + width, y2 + width, color);		
> 		} */
6774a6944,6952
> 	/*
> 	 * Lock the surface 
> 	 */
> 	if (SDL_MUSTLOCK(dst)) {
> 	  SDL_LockSurface(dst);
> 	}
> 
> 	m.drawRoutine = getDrawRoutine( dst, m.alpha );
> 	
6776c6954,6959
< 	_murphyWideline(&m, x1, y1, x2, y2, width, 1);
---
> 	//	_murphyWideline(&m, x1, y1, x2, y2, width, 1);
> 
> 	/* Unlock surface */
> 	if (SDL_MUSTLOCK(dst)) {
> 	  SDL_UnlockSurface(dst);
> 	}
6779a6963
> 
diff SDL_gfx-2.0.23/SDL_gfxPrimitives.h SDL_gfx-2.0.23-xcs/SDL_gfxPrimitives.h
120a121,122
> 	SDL_GFXPRIMITIVES_SCOPE int thickPatternedLineColor(SDL_Surface * dst, Sint16 x1, Sint16 y1, Sint16 x2, Sint16 y2, 
> 							    Uint8 width, Uint32 color, Uint8 pattern);
200a203,204
>         SDL_GFXPRIMITIVES_SCOPE int thickPatternedPolygonColor(SDL_Surface * dst, const Sint16 * vx, const Sint16 * vy, int n, Uint8 width, Uint32 color, Uint8 pattern);
>         SDL_GFXPRIMITIVES_SCOPE int thickPolygonColor(SDL_Surface * dst, const Sint16 * vx, const Sint16 * vy, int n, Uint8 width, Uint32 color);
239a244
> 
Common subdirectories: SDL_gfx-2.0.23/Test and SDL_gfx-2.0.23-xcs/Test
